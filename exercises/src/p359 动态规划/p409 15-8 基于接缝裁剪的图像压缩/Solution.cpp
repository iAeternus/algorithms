/*
（基于接缝裁剪(seam carving)的图像压缩）给定一幅彩色图像，
它由一个 m × n 的像素数组 A [ 1.. m , 1.. n ] 构成，
每个像素是一个红绿蓝(RGB)亮度的三元组。假定我们希望轻度压缩这幅图像。
具体来说，我们希望从每一行中删除一个像素，使得图像变窄一个像素。
但为了避免影响视觉效果，我们要求相邻两行中删除的像素必须位于同一列或相邻列。
也就是说，删除的像素构成从顶端行到底端行的一条“接缝”(seam)，相邻像素均在垂直或对角线方向上相邻。
　　a. 证明：可能的接缝的数量是 m 的指数函数，假定n > 1。
　　b. 假定现在对每个像素A [ i , j ]，
    我们都已计算出一个实型的“破坏度” d [ i , j ]，
    表示删除像素 A [ i , j ] 对图像可视效果的破坏程序。
    直观地，一个像素的破坏度越低，它与相邻像素的相似度越高。
    再假定一条接缝的破坏度定义为它包含的像素的破坏度之和。
    设计算法，寻找破坏度最低的接缝。分析算法的时间复杂度。
-----------------------------------------------------------------------------------
a. m*2^(n - 1) <= x <= m*(3^n - 1)
*/
#include <iostream>
#include <vector>
#include <tuple>

enum Direction { U, LU, RU }; // i - 1 的选择：上、左上、右上

/**
 * @brief 求解图像最小破坏度接缝问题
 * @param d 图像中每个像素的破坏度
 * @return 以每个点结尾的接缝的破坏度数组 dp
 * @return 以每个点结尾的接缝中，该点上一个选择那个删除点 rec
 * @return 最后一个删除点位置 last
*/
std::tuple<std::vector<std::vector<double>>, std::vector<std::vector<Direction>>, int>
Min_Diraction_Seam(std::vector<std::vector<double>>& d)
{
    int m = d.size();
    int n = d[0].size();
    std::vector<std::vector<double>> dp(m, std::vector<double>(n));
    std::vector<std::vector<Direction>> rec(m, std::vector<Direction>(n));
    // base case
    for(int j = 0; j < n; j++)
    {
        dp[0][j] = d[0][j];
    }

    // 动态规划
    for(int i = 1; i < m; i++)
    {
        for(int j = 0; j < n; j++)
        {
            dp[i][j] = dp[i - 1][j];
            rec[i][j] = U; // 选上方
            if(j != 0 && dp[i - 1][j - 1] < dp[i][j])
            {
                dp[i][j] = dp[i - 1][j - 1];
                rec[i][j] = LU; // 选左上
            }
            if(j != n - 1 && dp[i - 1][j + 1] < dp[i][j])
            {
                dp[i][j] = dp[i - 1][j + 1];
                rec[i][j] = RU; // 选右上
            }
            dp[i][j] += d[i][j]; // 加上 (i, j) 处的破坏度
        }
    }

    double last_dp = dp[m - 1][0];
    int last = 1;
    for(int j = 1; j < n; j++)
    {
        if(dp[m - 1][j] < last_dp)
        {
            last_dp = dp[m - 1][j];
            last = j;
        }
    }

    return std::make_tuple(dp, rec, last);
}

/**
 * @brief 打印以点(i, j)为结尾的接缝中每个点的位置
 * @param rec
 * @param i 结尾点的横向偏移量
 * @param j 结尾点的纵向偏移量
*/
void Print_Seam(std::vector<std::vector<Direction>>& rec, int i, int j)
{
    if(i > 0)
    {
        Print_Seam(rec, i - 1, j + rec[i][j]);
    }
    std::cout << '(' << i << ", " << j << ')' << std::endl;
}

int main()
{
    std::vector<std::vector<double>> d = {
        {0.8, 0.2, 0.1, 0.5, 0.3, 0.9, 0.6, 0.7, 0.4, 0.8, 0.3, 0.5, 0.2, 0.7, 0.9, 0.4, 0.6, 0.1, 0.2, 0.8},
        {0.4, 1.0, 0.7, 0.2, 0.6, 0.8, 0.3, 0.1, 0.9, 0.4, 0.7, 0.5, 0.3, 0.2, 0.1, 0.6, 0.8, 0.9, 0.5, 0.4},
        {0.6, 0.3, 0.9, 0.7, 0.1, 0.4, 0.2, 0.5, 0.8, 0.3, 0.6, 0.9, 0.7, 0.2, 0.4, 0.1, 0.5, 0.8, 0.9, 0.6},
        {0.1, 0.5, 0.8, 0.3, 0.9, 0.4, 0.6, 0.7, 0.2, 0.5, 0.3, 0.9, 0.8, 0.7, 0.6, 0.4, 0.1, 0.2, 0.9, 0.3},
        {0.7, 0.2, 0.4, 0.8, 0.6, 0.1, 0.9, 0.3, 0.5, 0.7, 0.4, 0.2, 0.8, 0.6, 0.1, 0.3, 0.9, 0.5, 0.7, 0.4},
        {0.5, 0.9, 0.6, 0.2, 0.8, 0.3, 0.7, 0.1, 0.4, 0.2, 0.9, 0.5, 0.6, 0.7, 0.3, 0.1, 0.8, 0.4, 0.5, 0.9},
        {0.3, 0.6, 0.2, 0.7, 0.9, 0.5, 0.1, 0.8, 0.4, 0.6, 0.7, 0.3, 0.2, 0.4, 0.9, 0.8, 0.5, 0.3, 0.1, 0.6},
        {0.9, 0.4, 0.5, 0.1, 0.3, 0.6, 0.8, 0.2, 0.7, 0.9, 0.4, 0.6, 0.1, 0.5, 0.3, 0.9, 0.2, 0.7, 0.8, 0.4},
        {0.2, 0.7, 0.9, 0.4, 0.5, 0.8, 0.6, 0.3, 0.1, 0.2, 0.8, 0.9, 0.4, 0.7, 0.5, 0.3, 0.9, 0.1, 0.6, 0.2},
        {0.8, 0.3, 0.6, 0.9, 0.7, 0.2, 0.4, 0.1, 0.5, 0.3, 0.9, 0.6, 0.8, 0.9, 0.2, 0.4, 0.6, 0.7, 0.1, 0.3},
        {0.3, 0.5, 0.8, 0.1, 0.4, 0.7, 0.9, 0.6, 0.2, 0.3, 0.5, 0.9, 0.7, 0.4, 0.1, 0.2, 0.8, 0.6, 0.3, 0.5},
        {0.5, 0.7, 0.4, 0.9, 0.2, 0.6, 0.1, 0.8, 0.3, 0.5, 0.7, 0.4, 0.2, 0.1, 0.6, 0.8, 0.9, 0.5, 0.4, 0.7},
        {0.2, 0.3, 0.2, 0.8, 0.7, 0.9, 0.5, 0.4, 0.1, 0.2, 0.3, 0.9, 0.8, 0.7, 0.6, 0.4, 0.5, 0.8, 0.9, 0.1},
        {0.7, 0.2, 0.4, 0.7, 0.4, 0.2, 0.8, 0.6, 0.1, 0.7, 0.9, 0.5, 0.3, 0.1, 0.2, 0.8, 0.6, 0.4, 0.7, 0.2},
        {0.9, 0.1, 0.1, 0.6, 0.6, 0.4, 0.5, 0.1, 0.8, 0.9, 0.2, 0.3, 0.7, 0.5, 0.6, 0.4, 0.1, 0.2, 0.9, 0.8},
        {0.4, 0.6, 0.5, 0.4, 0.1, 0.8, 0.2, 0.7, 0.6, 0.4, 0.5, 0.1, 0.9, 0.2, 0.8, 0.7, 0.3, 0.9, 0.4, 0.6},
        {0.6, 0.8, 0.9, 0.1, 0.3, 0.4, 0.6, 0.2, 0.7, 0.8, 0.2, 0.4, 0.1, 0.5, 0.7, 0.9, 0.6, 0.3, 0.1, 0.8},
        {0.1, 0.9, 0.8, 0.2, 0.5, 0.7, 0.4, 0.9, 0.2, 0.1, 0.8, 0.7, 0.6, 0.3, 0.5, 0.4, 0.7, 0.9, 0.6, 0.2},
        {0.2, 0.5, 0.9, 0.9, 0.7, 0.1, 0.3, 0.6, 0.9, 0.2, 0.4, 0.5, 0.8, 0.6, 0.7, 0.1, 0.2, 0.4, 0.3, 0.5},
        {0.8, 0.4, 0.6, 0.3, 0.4, 0.5, 0.1, 0.9, 0.6, 0.1, 0.3, 0.7, 0.9, 0.8, 0.2, 0.5, 0.3, 0.1, 0.7, 0.4}
    }; // 20 * 20 图像破坏度矩阵
    auto[dp, rec, last] = Min_Diraction_Seam(d);
    Print_Seam(rec, d.size() - 1, last);
    return 0;
}